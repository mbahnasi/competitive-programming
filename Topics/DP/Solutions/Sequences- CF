#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
/*  اللهم اجعل هذا في سبيلك  */

// link: https://codeforces.com/gym/101020/problem/D
// you need to try every possible index that have an elemet after it that is greater by 1
// subseq[i]+1 = subseq[i+1]
//to make this you can save all indicies of each number in a set so you need an array of sets

const int N = 2e4 + 5 ;
int n, arr[N] , dp[N] ;
set<int> nxt[N] ;

int maxSub(int i) {
    // no need here for base case as i mark dp[i] always with 1
    // dp magic:
    int &ret = dp[i] ;
    if (dp[i] != -1) return dp[i] ;
    //transition:
    ret = 1 ;
    auto it = nxt[arr[i]+1].upper_bound(i) ;
    if (it!= nxt[arr[i]+1].end()) ret = max(ret, maxSub(*it)+1) ;// take
    return ret ;
}

void solve() {
    cin >> n ;
    for (int i=0 ;i<N ;i++) {
        nxt[i].clear();
    }
    for (int i=0 ;i<n ;i++) {
        cin >> arr[i] ;
        nxt[arr[i]].emplace(i) ;
    }
    memset(dp, -1 , sizeof(dp)) ;
    int ans = 1;
    for (int i=0 ;i<n ;i++) ans = max(ans, maxSub(i)) ; // try every i to start the subsequence with it
    cout << ans <<'\n' ;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r",stdin);
    freopen("output.txt", "w",stdout);
#endif
    int tc;
    cin >> tc ;
    // tc = 1;
    while (tc--) solve();
}
