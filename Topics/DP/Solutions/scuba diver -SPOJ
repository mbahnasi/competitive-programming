#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
//اللهم اجعل هذا في سبيلك

// link : https://www.spoj.com/problems/SCUBADIV/

// it is somthing like a reversed knapsack
// you will minimize the weight of clyndiricals you will take to accomplish the needed Ox and Nit
// the trick here that you don't need to make a ddp of the whole size of clyndiricals
// as you don't need to exceed the Nit and Ox so they would be the size of 2nd and 3rd dimensions of dp
// dp[current index][remaining Ox][remaining Nit] = min Weight


int n , Ox, Nit, O[1003], N[1003], W[1003], dp[1003][200][500];

int minC(int i, int remO, int remN) {
    // base case : note that in dp you must try every possible way so the base case must be at last
    // i mean you can't return 0 at any time if the condition is satisfied becasuse may be there is a better sol
    if (i==n) {
        return remO >= Ox && remN >= Nit ? 0 : 1e9 ;
    }
    //dp magic:
    int &ret = dp[i][remO][remN] ;
    if (ret != -1) return ret ;
    // transition:
    int ch1 = W[i] + minC(i+1, min(Ox,remO+ O[i]) , min(remN + N[i], Nit)) ;// take the whole clyndirical
    int ch2 = minC(i+1,remO, remN) ;// leave
    return ret = min(ch1, ch2) ;
}
void solve() {
    cin >> Ox >> Nit ;
    cin >> n;
    for (int i=0 ;i<n ;i++){
        cin >> O[i] >> N[i] >> W[i] ;
    }
    memset(dp, -1, sizeof(dp)) ;
    cout << minC(0, 0, 0)<<'\n';
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r",stdin);
    freopen("output.txt", "w",stdout);
#endif
    int tc;
    cin >> tc ;
    // tc = 1;
    while (tc--) solve();
}
